{"ast":null,"code":"import _toConsumableArray from \"F:/Project-Legal.ly/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\n// This file is generated by `build.js`\n\n/**\n * @typedef {import('trigram-utils').TrigramTuple} TrigramTuple\n *\n * @typedef Options\n * @property {Array<string>} [only]\n *   Languages to allow.\n * @property {Array<string>} [ignore]\n *   Languages to ignore.\n * @property {number} [minLength=10]\n *   Minimum length to accept.\n */\n\n/* Load `trigram-utils`. */\nimport { asTuples } from 'trigram-utils';\n/* Load `expressions` (regular expressions matching\n * scripts). */\n\nimport { expressions } from './expressions.js';\n/* Load `data` (trigram information per language,\n * per script). */\n\nimport { data } from './data.js';\n/* Maximum sample length. */\n\nvar MAX_LENGTH = 2048;\n/* Minimum sample length. */\n\nvar MIN_LENGTH = 10;\n/* The maximum distance to add when a given trigram does\n * not exist in a trigram dictionary. */\n\nvar MAX_DIFFERENCE = 300;\nvar own = {}.hasOwnProperty;\n/* Construct trigram dictionaries. */\n\n/** @type {string} */\n\nvar script;\n/** @type {Record<string, Record<string, Record<string, number>>>} */\n\nvar numericData = {};\n\nfor (script in data) {\n  if (own.call(data, script)) {\n    var languages = data[script];\n    /** @type {string} */\n\n    var name = void 0;\n    numericData[script] = {};\n\n    for (name in languages) {\n      if (own.call(languages, name)) {\n        var model = languages[name].split('|');\n        /** @type {Record<string, number>} */\n\n        var trigrams = {};\n        var weight = model.length;\n\n        while (weight--) {\n          trigrams[model[weight]] = weight;\n        }\n\n        numericData[script][name] = trigrams;\n      }\n    }\n  }\n}\n/**\n * Get the most probable language for the given value.\n *\n * @param {string} [value]\n *   The value to test.\n * @param {Options} [options]\n *   Configuration.\n * @return {string}\n *  The most probable language.\n */\n\n\nexport function franc(value, options) {\n  return francAll(value, options)[0][0];\n}\n/**\n * Get a list of probable languages the given value is\n * written in.\n *\n * @param {string} [value]\n *   The value to test.\n * @param {Options} [options]\n *   Configuration.\n * @return {Array<TrigramTuple>}\n *   An array containing language—distance tuples.\n */\n\nexport function francAll(value) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  /** @type {Array<string>} */\n  // @ts-expect-error: `whitelist` is from long ago.\n  var only = [].concat(_toConsumableArray(options.whitelist || []), _toConsumableArray(options.only || []));\n  /** @type {Array<string>} */\n  // @ts-expect-error: `blacklist` is from long ago.\n\n  var ignore = [].concat(_toConsumableArray(options.blacklist || []), _toConsumableArray(options.ignore || []));\n  var minLength = options.minLength !== null && options.minLength !== undefined ? options.minLength : MIN_LENGTH;\n\n  if (!value || value.length < minLength) {\n    return und();\n  }\n\n  value = value.slice(0, MAX_LENGTH);\n  /* Get the script which characters occur the most\n   * in `value`. */\n\n  var script = getTopScript(value, expressions);\n  /* One languages exists for the most-used script. */\n\n  if (!script[0] || !(script[0] in numericData)) {\n    /* If no matches occured, such as a digit only string,\n     * or because the language is ignored, exit with `und`. */\n    if (!script[0] || script[1] === 0 || !allow(script[0], only, ignore)) {\n      return und();\n    }\n\n    return singleLanguageTuples(script[0]);\n  }\n  /* Get all distances for a given script, and\n   * normalize the distance values. */\n\n\n  return normalize(value, getDistances(asTuples(value), numericData[script[0]], only, ignore));\n}\n/**\n * Normalize the difference for each tuple in\n * `distances`.\n *\n * @param {string} value\n *   Value to normalize.\n * @param {Array<TrigramTuple>} distances\n *   List of distances.\n * @return {Array<TrigramTuple>}\n *   Normalized distances.\n */\n\nfunction normalize(value, distances) {\n  var min = distances[0][1];\n  var max = value.length * MAX_DIFFERENCE - min;\n  var index = -1;\n\n  while (++index < distances.length) {\n    distances[index][1] = 1 - (distances[index][1] - min) / max || 0;\n  }\n\n  return distances;\n}\n/**\n * From `scripts`, get the most occurring expression for\n * `value`.\n *\n * @param {string} value\n *   Value to check.\n * @param {Record<string, RegExp>} scripts\n *   Top-Scripts.\n * @return {[string|undefined, number]}\n *   Top script and its occurrence percentage.\n */\n\n\nfunction getTopScript(value, scripts) {\n  var topCount = -1;\n  /** @type {string|undefined} */\n\n  var topScript;\n  /** @type {string} */\n\n  var script;\n\n  for (script in scripts) {\n    if (own.call(scripts, script)) {\n      var count = getOccurrence(value, scripts[script]);\n\n      if (count > topCount) {\n        topCount = count;\n        topScript = script;\n      }\n    }\n  }\n\n  return [topScript, topCount];\n}\n/**\n * Get the occurrence ratio of `expression` for `value`.\n *\n * @param {string} value\n *   Value to check.\n * @param {RegExp} expression\n *   Code-point expression.\n * @return {number}\n *   Float between 0 and 1.\n */\n\n\nfunction getOccurrence(value, expression) {\n  var count = value.match(expression);\n  return (count ? count.length : 0) / value.length || 0;\n}\n/**\n * Get the distance between an array of trigram—count\n * tuples, and multiple trigram dictionaries.\n *\n * @param {Array<TrigramTuple>} trigrams\n *   An array containing trigram—count tuples.\n * @param {Record<string, Record<string, number>>} languages\n *   Multiple trigrams to test against.\n * @param {Array<string>} only\n *   Allowed languages; if non-empty, only included languages are kept.\n * @param {Array<string>} ignore\n *   Disallowed languages; included languages are ignored.\n * @return {Array<TrigramTuple>} An array\n *   containing language—distance tuples.\n */\n\n\nfunction getDistances(trigrams, languages, only, ignore) {\n  languages = filterLanguages(languages, only, ignore);\n  /** @type {Array<TrigramTuple>} */\n\n  var distances = [];\n  /** @type {string} */\n\n  var language;\n\n  if (languages) {\n    for (language in languages) {\n      if (own.call(languages, language)) {\n        distances.push([language, getDistance(trigrams, languages[language])]);\n      }\n    }\n  }\n\n  return distances.length === 0 ? und() : distances.sort(sort);\n}\n/**\n * Get the distance between an array of trigram—count\n * tuples, and a language dictionary.\n *\n * @param {Array<TrigramTuple>} trigrams\n *   An array containing trigram—count tuples.\n * @param {Record<string, number>} model\n *   Object containing weighted trigrams.\n * @return {number}\n *   The distance between the two.\n */\n\n\nfunction getDistance(trigrams, model) {\n  var distance = 0;\n  var index = -1;\n\n  while (++index < trigrams.length) {\n    var trigram = trigrams[index];\n    var difference = MAX_DIFFERENCE;\n\n    if (trigram[0] in model) {\n      difference = trigram[1] - model[trigram[0]] - 1;\n\n      if (difference < 0) {\n        difference = -difference;\n      }\n    }\n\n    distance += difference;\n  }\n\n  return distance;\n}\n/**\n * Filter `languages` by removing languages in\n * `ignore`, or including languages in `only`.\n *\n * @param {Record<string, Record<string, number>>} languages\n *   Languages to filter\n * @param {Array<string>} only\n *   Allowed languages; if non-empty, only included languages are kept.\n * @param {Array<string>} ignore\n *   Disallowed languages; included languages are ignored.\n * @return {Record<string, Record<string, number>>}\n *   Filtered array of languages.\n */\n\n\nfunction filterLanguages(languages, only, ignore) {\n  if (only.length === 0 && ignore.length === 0) {\n    return languages;\n  }\n  /** @type {Record<string, Record<string, number>>} */\n\n\n  var filteredLanguages = {};\n  /** @type {string} */\n\n  var language;\n\n  for (language in languages) {\n    if (allow(language, only, ignore)) {\n      filteredLanguages[language] = languages[language];\n    }\n  }\n\n  return filteredLanguages;\n}\n/**\n * Check if `language` can match according to settings.\n *\n * @param {string} language\n *   Languages to filter\n * @param {Array<string>} only\n *   Allowed languages; if non-empty, only included languages are kept.\n * @param {Array<string>} ignore\n *   Disallowed languages; included languages are ignored.\n * @return {boolean}\n *   Whether `language` can match\n */\n\n\nfunction allow(language, only, ignore) {\n  if (only.length === 0 && ignore.length === 0) {\n    return true;\n  }\n\n  return (only.length === 0 || only.includes(language)) && !ignore.includes(language);\n}\n/**\n * Create a single `und` tuple.\n */\n\n\nfunction und() {\n  return singleLanguageTuples('und');\n}\n/**\n * Create a single tuple as a list of tuples from a given language code.\n *\n * @param {string} language\n * @returns {Array<TrigramTuple>}\n */\n\n\nfunction singleLanguageTuples(language) {\n  return [[language, 1]];\n}\n/**\n * Deep regular sort on the number at `1` in both objects.\n *\n * @param {TrigramTuple} a\n * @param {TrigramTuple} b\n */\n\n\nfunction sort(a, b) {\n  return a[1] - b[1];\n}","map":{"version":3,"sources":["F:/Project-Legal.ly/node_modules/franc-min/index.js"],"names":["asTuples","expressions","data","MAX_LENGTH","MIN_LENGTH","MAX_DIFFERENCE","own","hasOwnProperty","script","numericData","call","languages","name","model","split","trigrams","weight","length","franc","value","options","francAll","only","whitelist","ignore","blacklist","minLength","undefined","und","slice","getTopScript","allow","singleLanguageTuples","normalize","getDistances","distances","min","max","index","scripts","topCount","topScript","count","getOccurrence","expression","match","filterLanguages","language","push","getDistance","sort","distance","trigram","difference","filteredLanguages","includes","a","b"],"mappings":"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","sourcesContent":["// This file is generated by `build.js`\n/**\n * @typedef {import('trigram-utils').TrigramTuple} TrigramTuple\n *\n * @typedef Options\n * @property {Array<string>} [only]\n *   Languages to allow.\n * @property {Array<string>} [ignore]\n *   Languages to ignore.\n * @property {number} [minLength=10]\n *   Minimum length to accept.\n */\n\n/* Load `trigram-utils`. */\nimport {asTuples} from 'trigram-utils'\n/* Load `expressions` (regular expressions matching\n * scripts). */\nimport {expressions} from './expressions.js'\n/* Load `data` (trigram information per language,\n * per script). */\nimport {data} from './data.js'\n\n/* Maximum sample length. */\nconst MAX_LENGTH = 2048\n\n/* Minimum sample length. */\nconst MIN_LENGTH = 10\n\n/* The maximum distance to add when a given trigram does\n * not exist in a trigram dictionary. */\nconst MAX_DIFFERENCE = 300\n\nconst own = {}.hasOwnProperty\n\n/* Construct trigram dictionaries. */\n\n/** @type {string} */\nlet script\n\n/** @type {Record<string, Record<string, Record<string, number>>>} */\nconst numericData = {}\n\nfor (script in data) {\n  if (own.call(data, script)) {\n    const languages = data[script]\n    /** @type {string} */\n    let name\n\n    numericData[script] = {}\n\n    for (name in languages) {\n      if (own.call(languages, name)) {\n        const model = languages[name].split('|')\n        /** @type {Record<string, number>} */\n        const trigrams = {}\n        let weight = model.length\n\n        while (weight--) {\n          trigrams[model[weight]] = weight\n        }\n\n        numericData[script][name] = trigrams\n      }\n    }\n  }\n}\n\n/**\n * Get the most probable language for the given value.\n *\n * @param {string} [value]\n *   The value to test.\n * @param {Options} [options]\n *   Configuration.\n * @return {string}\n *  The most probable language.\n */\nexport function franc(value, options) {\n  return francAll(value, options)[0][0]\n}\n\n/**\n * Get a list of probable languages the given value is\n * written in.\n *\n * @param {string} [value]\n *   The value to test.\n * @param {Options} [options]\n *   Configuration.\n * @return {Array<TrigramTuple>}\n *   An array containing language—distance tuples.\n */\nexport function francAll(value, options = {}) {\n  /** @type {Array<string>} */\n  // @ts-expect-error: `whitelist` is from long ago.\n  const only = [...(options.whitelist || []), ...(options.only || [])]\n  /** @type {Array<string>} */\n  // @ts-expect-error: `blacklist` is from long ago.\n  const ignore = [...(options.blacklist || []), ...(options.ignore || [])]\n  const minLength =\n    options.minLength !== null && options.minLength !== undefined\n      ? options.minLength\n      : MIN_LENGTH\n\n  if (!value || value.length < minLength) {\n    return und()\n  }\n\n  value = value.slice(0, MAX_LENGTH)\n\n  /* Get the script which characters occur the most\n   * in `value`. */\n  const script = getTopScript(value, expressions)\n\n  /* One languages exists for the most-used script. */\n  if (!script[0] || !(script[0] in numericData)) {\n    /* If no matches occured, such as a digit only string,\n     * or because the language is ignored, exit with `und`. */\n    if (!script[0] || script[1] === 0 || !allow(script[0], only, ignore)) {\n      return und()\n    }\n\n    return singleLanguageTuples(script[0])\n  }\n\n  /* Get all distances for a given script, and\n   * normalize the distance values. */\n  return normalize(\n    value,\n    getDistances(asTuples(value), numericData[script[0]], only, ignore)\n  )\n}\n\n/**\n * Normalize the difference for each tuple in\n * `distances`.\n *\n * @param {string} value\n *   Value to normalize.\n * @param {Array<TrigramTuple>} distances\n *   List of distances.\n * @return {Array<TrigramTuple>}\n *   Normalized distances.\n */\nfunction normalize(value, distances) {\n  const min = distances[0][1]\n  const max = value.length * MAX_DIFFERENCE - min\n  let index = -1\n\n  while (++index < distances.length) {\n    distances[index][1] = 1 - (distances[index][1] - min) / max || 0\n  }\n\n  return distances\n}\n\n/**\n * From `scripts`, get the most occurring expression for\n * `value`.\n *\n * @param {string} value\n *   Value to check.\n * @param {Record<string, RegExp>} scripts\n *   Top-Scripts.\n * @return {[string|undefined, number]}\n *   Top script and its occurrence percentage.\n */\nfunction getTopScript(value, scripts) {\n  let topCount = -1\n  /** @type {string|undefined} */\n  let topScript\n  /** @type {string} */\n  let script\n\n  for (script in scripts) {\n    if (own.call(scripts, script)) {\n      const count = getOccurrence(value, scripts[script])\n\n      if (count > topCount) {\n        topCount = count\n        topScript = script\n      }\n    }\n  }\n\n  return [topScript, topCount]\n}\n\n/**\n * Get the occurrence ratio of `expression` for `value`.\n *\n * @param {string} value\n *   Value to check.\n * @param {RegExp} expression\n *   Code-point expression.\n * @return {number}\n *   Float between 0 and 1.\n */\nfunction getOccurrence(value, expression) {\n  const count = value.match(expression)\n\n  return (count ? count.length : 0) / value.length || 0\n}\n\n/**\n * Get the distance between an array of trigram—count\n * tuples, and multiple trigram dictionaries.\n *\n * @param {Array<TrigramTuple>} trigrams\n *   An array containing trigram—count tuples.\n * @param {Record<string, Record<string, number>>} languages\n *   Multiple trigrams to test against.\n * @param {Array<string>} only\n *   Allowed languages; if non-empty, only included languages are kept.\n * @param {Array<string>} ignore\n *   Disallowed languages; included languages are ignored.\n * @return {Array<TrigramTuple>} An array\n *   containing language—distance tuples.\n */\nfunction getDistances(trigrams, languages, only, ignore) {\n  languages = filterLanguages(languages, only, ignore)\n\n  /** @type {Array<TrigramTuple>} */\n  const distances = []\n  /** @type {string} */\n  let language\n\n  if (languages) {\n    for (language in languages) {\n      if (own.call(languages, language)) {\n        distances.push([language, getDistance(trigrams, languages[language])])\n      }\n    }\n  }\n\n  return distances.length === 0 ? und() : distances.sort(sort)\n}\n\n/**\n * Get the distance between an array of trigram—count\n * tuples, and a language dictionary.\n *\n * @param {Array<TrigramTuple>} trigrams\n *   An array containing trigram—count tuples.\n * @param {Record<string, number>} model\n *   Object containing weighted trigrams.\n * @return {number}\n *   The distance between the two.\n */\nfunction getDistance(trigrams, model) {\n  let distance = 0\n  let index = -1\n\n  while (++index < trigrams.length) {\n    const trigram = trigrams[index]\n    let difference = MAX_DIFFERENCE\n\n    if (trigram[0] in model) {\n      difference = trigram[1] - model[trigram[0]] - 1\n\n      if (difference < 0) {\n        difference = -difference\n      }\n    }\n\n    distance += difference\n  }\n\n  return distance\n}\n\n/**\n * Filter `languages` by removing languages in\n * `ignore`, or including languages in `only`.\n *\n * @param {Record<string, Record<string, number>>} languages\n *   Languages to filter\n * @param {Array<string>} only\n *   Allowed languages; if non-empty, only included languages are kept.\n * @param {Array<string>} ignore\n *   Disallowed languages; included languages are ignored.\n * @return {Record<string, Record<string, number>>}\n *   Filtered array of languages.\n */\nfunction filterLanguages(languages, only, ignore) {\n  if (only.length === 0 && ignore.length === 0) {\n    return languages\n  }\n\n  /** @type {Record<string, Record<string, number>>} */\n  const filteredLanguages = {}\n  /** @type {string} */\n  let language\n\n  for (language in languages) {\n    if (allow(language, only, ignore)) {\n      filteredLanguages[language] = languages[language]\n    }\n  }\n\n  return filteredLanguages\n}\n\n/**\n * Check if `language` can match according to settings.\n *\n * @param {string} language\n *   Languages to filter\n * @param {Array<string>} only\n *   Allowed languages; if non-empty, only included languages are kept.\n * @param {Array<string>} ignore\n *   Disallowed languages; included languages are ignored.\n * @return {boolean}\n *   Whether `language` can match\n */\nfunction allow(language, only, ignore) {\n  if (only.length === 0 && ignore.length === 0) {\n    return true\n  }\n\n  return (\n    (only.length === 0 || only.includes(language)) && !ignore.includes(language)\n  )\n}\n\n/**\n * Create a single `und` tuple.\n */\nfunction und() {\n  return singleLanguageTuples('und')\n}\n\n/**\n * Create a single tuple as a list of tuples from a given language code.\n *\n * @param {string} language\n * @returns {Array<TrigramTuple>}\n */\nfunction singleLanguageTuples(language) {\n  return [[language, 1]]\n}\n\n/**\n * Deep regular sort on the number at `1` in both objects.\n *\n * @param {TrigramTuple} a\n * @param {TrigramTuple} b\n */\nfunction sort(a, b) {\n  return a[1] - b[1]\n}\n"]},"metadata":{},"sourceType":"module"}